import java.io.BufferedWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * 
 * Effects the actual compilation output. Gets its input from a JackTokenizer and emits its parsed 
 * structure into an output file/stream. The output is generated by a series of compilexxx() 
 * routines, one for every syntactic element xxx of the Jack grammar. The contract between these 
 * routines is that each compilexxx() routine should read the syntactic construct xxx from the 
 * input, advance() the tokenizer exactly beyond xxx , and output the parsing of xxx . Thus, 
 * compilexxx() may only be called if indeed xxx is the next syntactic element of the input.
 * 
 * @author yuval & eric
 *
 */
public class CompilationEngine {
	
	public static final String IF_TURE_LABEL = "IF_TRUE"; 
	public static final String IF_FALSE_LABEL = "IF_FALSE";
	public static final String IF_END_LABEL = "IF_END";
	public static final String WHILE_EXP_LABEL = "WHILE_EXP";
	public static final String WHILE_END_LABEL = "WHILE_END";
	
	private static HashMap<String, String> opToCmd = new HashMap<>();
	static {
		opToCmd.put("+", "add");
		opToCmd.put("-", "sub");
		opToCmd.put("=", "eq");
		opToCmd.put("&gt;", "gt");
		opToCmd.put("&lt;", "lt");
		opToCmd.put("&amp;", "and");
		opToCmd.put("|", "or");
		opToCmd.put("~", "not");
	}
	
	private static HashMap<String, String> unaryOpToCmd = new HashMap<>();
	static {
		opToCmd.put("-", "neg");
		opToCmd.put("~", "not");
	}
	
	private static HashSet<String> osObjects = new HashSet<>();
	static {
		osObjects.add("Memory");
		osObjects.add("String");
		osObjects.add("Math");
		osObjects.add("Array");
		osObjects.add("Output");
		osObjects.add("Screen");
		osObjects.add("Keyboard");
		osObjects.add("Sys");
	}
	
	private static HashSet<String> types = new HashSet<>();
	static {
		types.add("int");
		types.add("char");
		types.add("boolean");
		types.add("Array");
		types.add("String");
	}

	/* The tokenizer */
	private JackTokenizer tokenizer;
	/* The VM writer file */
	private VMWriter writer;
	/* The Symbol Table */
	private SymbolTable st;
	
	private int ifLabelCounter;
	private int whileLabelCounter;
	
	private String className;
	
	/**
	 * The constructor. Gets the tokenizer and the output buffer.   
	 * 
	 * @param tokenizer
	 * @param outputFile
	 */
	public CompilationEngine(JackTokenizer tokenizer, VMWriter outputFile) {
		
		this.tokenizer = tokenizer;
		this.writer = outputFile;
		this.st = new SymbolTable();
		this.ifLabelCounter = 0;
		this.whileLabelCounter = 0;
	}
	
	/**
	 * Generate the XML file.
	 * @throws IOException
	 */
	public void generateVM() throws IOException {
		compileClass();
		this.writer.close();
		this.tokenizer.close();
	}

	
	/**
	 * Compiles a complete class.
	 * @throws IOException
	 */
	private void compileClass() throws IOException{
		
		this.tokenizer.advance(); // class
		this.tokenizer.advance(); // class name
		this.className = this.tokenizer.identifier();
		
		//System.out.println("--------------------------------------------- " + this.className + " ------------------------------------------------");
		
		this.tokenizer.advance(); // {
		
		//this.tokenizer.advance();
		
		while(this.tokenizer.hasMoreTokens()){
			
			this.tokenizer.advance();
			
			// if the class is over
			
			if(this.tokenizer.tokenType().equals(JackTokenizer.TT_SYMBOL)){
				if(this.tokenizer.symbol().equals("}")){
					break;
				}	
			}
			
			
			
			switch(this.tokenizer.tokenType()) {
			case JackTokenizer.TT_KEYWORD:
				switch(this.tokenizer.keyWord()) {
				case "static":
				case "field":
					compileClassVarDec();
					break;
				case "constructor":
				case "function":
				case "method":
					compileSubroutineDec();
					break;
				}
			}
			
			
		}
		
	}
	
	/**
	 * Compiles a static declaration or a field declaration.
	 * @throws IOException
	 */
	private void compileClassVarDec() throws IOException {
		
		String kind;
		String name;
		String type;
		
		kind = this.tokenizer.keyWord(); 
		this.tokenizer.advance();
		if(this.tokenizer.tokenType().equals(JackTokenizer.TT_KEYWORD)) {
			type = this.tokenizer.keyWord();
		} else {
			type = this.tokenizer.identifier();
		}
		this.tokenizer.advance();
		name  = this.tokenizer.identifier();
		
		this.st.define(name, type, IdentifierKind.getKind(kind));
		
		while(this.tokenizer.peekVal().equals(",")) {
			
			this.tokenizer.advance(); // ,
			this.tokenizer.advance();
			name  = this.tokenizer.identifier();
			
			this.st.define(name, type, IdentifierKind.getKind(kind)); 
		}
		
		this.tokenizer.advance(); // ;
	}
	
	/**
	 * Compiles a complete varible decliration
	 * @throws IOException
	 */
	private void compileSubroutineDec() throws IOException {
		
		this.st.startSubroutine(); // start a new subroutine symbol table
		this.ifLabelCounter = 0;
		this.whileLabelCounter = 0;
		
		String subroutineType = this.tokenizer.keyWord();

		this.tokenizer.advance(); // return type
		this.tokenizer.advance(); // function Name
		String funcName = this.tokenizer.identifier();
		
		this.tokenizer.advance(); // (
		
		complieParameterList();
		
		this.tokenizer.advance(); // )
	
		compileSubroutineBody();
		
		this.writer.writeFunction(this.className + "." + funcName, 
				this.st.varCount(IdentifierKind.VAR));
		
		switch(subroutineType) {
		
		case "constructor":
			this.writer.writePush(Segment.CONST, this.st.varCount(IdentifierKind.FIELD));
			this.writer.writeCall("Memory.alloc", 1);
			this.writer.writePop(Segment.POINTER, 0);		
			break;
		case "function":
			break;
		case "method":
			this.writer.writePush(Segment.ARG, 0);
			this.writer.writePop(Segment.POINTER, 0);
			break;
		
		}
		
		compileStatements();
		
		this.tokenizer.advance(); // }
		
	}
	
	/**
	 * Compiles a complete method, function, or constructor.
	 * @throws IOException
	 */
	private void compileSubroutineBody() throws IOException {
		
		this.tokenizer.advance(); // {
		
		while(this.tokenizer.peekVal().equals("var")) {
			
			compileVarDec();
		}
		
	}
	
	/**
	 * Compiles a (possibly empty) parameter list, not including the enclosing “ () ”.
	 * @throws IOException
	 */
	private void complieParameterList() throws IOException {
		
		String type;
		String name;
		
		while(this.tokenizer.hasMoreTokens()) {
			
			if(this.tokenizer.peekVal().equals(")")) {
				break;
			}
			
			this.tokenizer.advance(); // argument's type
			if(this.tokenizer.tokenType().equals(JackTokenizer.TT_IDENTIFIER)) {
				type = this.tokenizer.identifier();
			} else {
				type = this.tokenizer.keyWord();
			}
			this.tokenizer.advance(); // argument's name
			name = this.tokenizer.identifier();
			
			this.st.define(name, type, IdentifierKind.ARG); // enter new argument to the symbol table
			
			if(this.tokenizer.peekVal().equals(",")) {
				this.tokenizer.advance(); // ,
			}
			
		}
		
	}	
	/**
	 * Compiles a var declaration.
	 * @throws IOException
	 */
	private void compileVarDec() throws IOException {
	
		
		this.tokenizer.advance(); // var
		String type;
		String name;
		
		this.tokenizer.advance(); // type
		
		if(this.tokenizer.tokenType().equals(JackTokenizer.TT_IDENTIFIER)) {
			type = this.tokenizer.identifier();
		} else {
			type = this.tokenizer.keyWord();
		}
		this.tokenizer.advance(); // argument's name
		name = this.tokenizer.identifier();
		
		this.st.define(name, type, IdentifierKind.VAR); // enter new local to the symbol table
		
		while(this.tokenizer.peekVal().equals(",")) {
			this.tokenizer.advance(); // ,
			this.tokenizer.advance(); // argument's name
			name = this.tokenizer.identifier();
			
			this.st.define(name, type, IdentifierKind.VAR); // enter new local to the symbol table
		}
		
		this.tokenizer.advance(); // ;
		
	}
	
	/**
	 * Compiles a sequence of statements, not including the enclosing “ {} ”.
	 * @throws IOException
	 */
	private void compileStatements() throws IOException {
		
		
		while(this.tokenizer.hasMoreTokens()) {
			if(this.tokenizer.peekVal().equals("}")) {
				break;
			}
			compileStatement();
		}
		
	}
	
	/**
	 * Choose which statement to compile according to next token.  
	 * @throws IOException
	 */
	private void compileStatement() throws IOException {
		
		switch(this.tokenizer.peekVal()) {
		case "let":
			compileLet();
			break;
		case "if":
			compileIf();
			break;
		case "do":
			compileDo();
			break;
		case "while":
			compileWhile();
			break;
		case "return":
			compileReturn();
			break;
		}

	}
	
	/**
	 * Compiles a let statement.
	 * @throws IOException
	 */
	private void compileLet() throws IOException {
		
		this.tokenizer.advance(); // let
		this.tokenizer.advance(); // source name
		String sourceName = this.tokenizer.identifier();
		
		IdentifierKind sourceKind = this.st.kindOf(sourceName);
		int sourceIndex =  this.st.indexOf(sourceName);
		
		if(this.tokenizer.peekVal().equals("[")) {
			
			this.tokenizer.advance(); // [
			compileExpression();
			this.tokenizer.advance(); // ]
			if(sourceKind.equals(IdentifierKind.FIELD)) {
				this.writer.writePush(Segment.THIS, sourceIndex);
			} else {
				this.writer.writePush(Segment.getSegment(IdentifierKind.getValue(sourceKind)), sourceIndex);
			}
			
			this.writer.writeArithmetic("add");
			this.tokenizer.advance(); // = 
			
			compileExpression();
			
			this.writer.writePop(Segment.TEMP, 0);
			this.writer.writePop(Segment.POINTER, 1);
			this.writer.writePush(Segment.TEMP, 0);
			this.writer.writePop(Segment.THAT, 0);
			
		} else { // no array
			this.tokenizer.advance(); // = 
			compileExpression();
			if(sourceKind.equals(IdentifierKind.FIELD)) {
				this.writer.writePop(Segment.THIS, sourceIndex);
			} else {
				this.writer.writePop(Segment.getSegment(IdentifierKind.getValue(sourceKind)), sourceIndex);
			}
		}
		
		this.tokenizer.advance(); // ;
		
	}
	
	/**
	 * Compiles a if statement.
	 * @throws IOException
	 */
	private void compileIf() throws IOException {
		this.tokenizer.advance(); // if
		
		int currentIfCounter = this.ifLabelCounter;
		this.ifLabelCounter++;
		
		this.tokenizer.advance(); // (
		compileExpression();
		this.tokenizer.advance(); // )
		
		this.writer.writeIf(CompilationEngine.IF_TURE_LABEL + Integer.toString(currentIfCounter));
		this.writer.writeGoto(CompilationEngine.IF_FALSE_LABEL + Integer.toString(currentIfCounter));
		this.writer.writeLabel(CompilationEngine.IF_TURE_LABEL + Integer.toString(currentIfCounter));
		
		this.tokenizer.advance(); // {
		compileStatements();
		this.tokenizer.advance(); // }
		
		// check if there is "else" statement
		if(this.tokenizer.peekVal().equals("else")) {
			this.writer.writeGoto(CompilationEngine.IF_END_LABEL + Integer.toString(currentIfCounter));
			this.writer.writeLabel(CompilationEngine.IF_FALSE_LABEL + Integer.toString(currentIfCounter));
			this.tokenizer.advance(); // else
			
			this.tokenizer.advance(); // {
			compileStatements();
			this.tokenizer.advance(); // }
			
			this.writer.writeLabel(CompilationEngine.IF_END_LABEL + Integer.toString(currentIfCounter));
		} else {
			this.writer.writeLabel(CompilationEngine.IF_FALSE_LABEL + Integer.toString(currentIfCounter));
		}
	
		//this.ifLabelCounter++;
	}
	
	/**
	 * Compiles a while statement.
	 * @throws IOException
	 */
	private void compileWhile() throws IOException {
		this.tokenizer.advance(); // while
		
		int currentWhileCounter = this.whileLabelCounter;
		this.whileLabelCounter++;
		
		this.writer.writeLabel(CompilationEngine.WHILE_EXP_LABEL + Integer.toString(currentWhileCounter));
		
		this.tokenizer.advance(); // (
		compileExpression();
		this.tokenizer.advance(); // )
		
		this.writer.writeArithmetic(CompilationEngine.opToCmd.get("~"));
		
		this.writer.writeIf(CompilationEngine.WHILE_END_LABEL + Integer.toString(currentWhileCounter));
		
		this.tokenizer.advance(); // {
		compileStatements();
		this.tokenizer.advance(); // }
		
		this.writer.writeGoto(CompilationEngine.WHILE_EXP_LABEL + Integer.toString(currentWhileCounter));
		this.writer.writeLabel(CompilationEngine.WHILE_END_LABEL + Integer.toString(currentWhileCounter));
		
	}
	
	/**
	 * Compiles a do statement.
	 * @throws IOException
	 */
	private void compileDo() throws IOException {
			
		this.tokenizer.advance(); // do
		
		compileSubroutineCall();
		
		this.tokenizer.advance(); // ;
		
		this.writer.writePop(Segment.TEMP, 0);
		
	}
	
	/**
	 * Compiles a return statement.
	 * @throws IOException
	 */
	private void compileReturn() throws IOException {
		
		this.tokenizer.advance(); // return
		
		if(this.tokenizer.peekVal().equals(";")) {
			this.writer.writePush(Segment.CONST, 0);
		} else {
			compileExpression();
		}
		
		this.tokenizer.advance(); // ;
		
		this.writer.writeReturn();
		
		
	}
	
	/**
	 * Compiles an expression.
	 * @throws IOException
	 */
	private void compileExpression() throws IOException {
		
		//System.out.println("enter to exoression " + this.tokenizer.peekVal());
		
		String operation;
		
		compileTerm();
		
		while(JackTokenizer.op.contains(this.tokenizer.peekVal())) {
			this.tokenizer.advance(); // operation
			
			operation = this.tokenizer.symbol();
			
			compileTerm();
			if(operation.equals("/")) {
				this.writer.writeCall("Math.divede", 2);
			} else if (operation.equals("*")) {
				this.writer.writeCall("Math.multiply", 2);
			} else {
				this.writer.writeArithmetic(CompilationEngine.opToCmd.get(operation));
			}
		}
	}
	
	/**
	 * Compiles a subroutine call.
	 * @throws IOException
	 */
	private void compileSubroutineCall() throws IOException {
		
		this.tokenizer.advance(); // function name
		
		String objectName = this.tokenizer.identifier();
		int argsNum = 0;
		
		String beforePeek = this.tokenizer.identifier();
		
		if(this.tokenizer.peekVal().equals(".")) {
			
			if(!(CompilationEngine.osObjects.contains(objectName))) {
				objectName = this.st.typeOf(beforePeek);
				if(objectName == null) {
					objectName = beforePeek;
				} else {
				
					IdentifierKind objKind = this.st.kindOf(beforePeek);
					
					int objIndex = this.st.indexOf(beforePeek);
					
					if(objKind.equals(IdentifierKind.FIELD)) {
						this.writer.writePush(Segment.THIS, objIndex);
					} else {
						this.writer.writePush(Segment.getSegment(IdentifierKind.getValue(objKind)), objIndex);
					}
					argsNum++;
				}
			}

			
			this.tokenizer.advance(); // .
			this.tokenizer.advance(); // name
			objectName += "." + this.tokenizer.identifier();
			
			
		} else {
			objectName = this.className + "." + beforePeek;
		}
		
		this.tokenizer.advance(); // (
		argsNum += compileExpressionList();
		this.tokenizer.advance(); // )
		
		this.writer.writeCall(objectName, argsNum);
		
		
	}
	
	/**
	 * ompiles a term. This routine is faced with a slight difficulty when trying to decide between
	 * some of the alternative parsing rules. Specifically, if the current token is an identifier, 
	 * the routine must distinguish between a variable, an array entry, and a subroutine call. 
	 * A single look-ahead token, which may be one of “ [ “, “ ( “, or “ . ” suffices to distinguish
	 * between the three possibilities. Any other token is not part of this term and should not 
	 * be advanced over.
	 * @throws IOException
	 */
	private void compileTerm() throws IOException {
		
		// TODO when call subroutineCall in case of identifier
		
		//System.out.println("enter term : " + this.tokenizer.peekType());
		
		switch(this.tokenizer.peekType()) {
		
		case JackTokenizer.TT_IDENTIFIER:
			
			String beforePeek = this.tokenizer.peekVal();
			
			IdentifierKind varKind = this.st.kindOf(beforePeek);
			
			String varType = this.st.typeOf(beforePeek);
		
			
			int varIndex = this.st.indexOf(beforePeek);
			if(varKind == null) {
				compileSubroutineCall();
			} /*else if(!(CompilationEngine.types.contains(varType)))  {
				compileSubroutineCall();
			}*/ else {
				this.tokenizer.advance(); // varName
				
				beforePeek = this.tokenizer.identifier();
				
				if(this.tokenizer.peekVal().equals(".") || this.tokenizer.peekVal().equals("(")) {
					
					String objectName = this.tokenizer.identifier();
					int argsNum = 0;
					
					beforePeek = this.tokenizer.identifier();
					
					if(this.tokenizer.peekVal().equals(".")) {
						
						if(!(CompilationEngine.osObjects.contains(objectName))) {
							objectName = this.st.typeOf(beforePeek);
							if(objectName == null) {
								objectName = beforePeek;
							} else {
							
								IdentifierKind objKind = this.st.kindOf(beforePeek);
								
								int objIndex = this.st.indexOf(beforePeek);
								
								if(objKind.equals(IdentifierKind.FIELD)) {
									this.writer.writePush(Segment.THIS, objIndex);
								} else {
									this.writer.writePush(Segment.getSegment(IdentifierKind.getValue(objKind)), objIndex);
								}
								argsNum++;
							}
						}

						
						this.tokenizer.advance(); // .
						this.tokenizer.advance(); // name
						objectName += "." + this.tokenizer.identifier();
						
						
					} else {
						objectName = this.className + "." + beforePeek;
					}
					
					this.tokenizer.advance(); // (
					argsNum += compileExpressionList();
					this.tokenizer.advance(); // )
					
					this.writer.writeCall(objectName, argsNum);
					
				} else if(this.tokenizer.peekVal().equals("[")) {
					this.tokenizer.advance(); // [
					compileExpression();
					this.tokenizer.advance(); // ]
					if(varKind.equals(IdentifierKind.FIELD)) {
						this.writer.writePush(Segment.THIS, varIndex);	
					} else {
						this.writer.writePush(Segment.getSegment(IdentifierKind.getValue(varKind)), varIndex);
					}
					this.writer.writeArithmetic("add");
					this.writer.writePop(Segment.POINTER, 1);
					this.writer.writePush(Segment.THAT, 0);

				} else {
					if(varKind.equals(IdentifierKind.FIELD)) {
						this.writer.writePush(Segment.THIS, varIndex);
					} else {
						this.writer.writePush(Segment.getSegment(IdentifierKind.getValue(varKind)), varIndex);
					}
					//this.tokenizer.advance();
				}
			}
			break;
			
		case JackTokenizer.TT_INT_COSNT:
			this.tokenizer.advance();
			this.writer.writePush(Segment.CONST, this.tokenizer.intVal());
			break;
			
		case JackTokenizer.TT_KEYWORD:
			// false, true, null, this
			this.tokenizer.advance();
			switch(this.tokenizer.keyWord()) {
			case "true":
				this.writer.writePush(Segment.CONST, 0);
				this.writer.writeArithmetic("not");
				break;
			case "false":
			case "null":
				this.writer.writePush(Segment.CONST, 0);
				break;
			case "this":
				this.writer.writePush(Segment.POINTER, 0);
				break;
			}
			break;
			
		case JackTokenizer.TT_STRING_CONST:
			this.tokenizer.advance();
			String theString = this.tokenizer.stringVal();
			this.writer.writePush(Segment.CONST, theString.length());
			this.writer.writeCall("String.new", 1);
			for(int i = 0; i < theString.length(); i++) {
				int asciiVal = theString.charAt(i);
				this.writer.writePush(Segment.CONST, asciiVal);
				this.writer.writeCall("String.appendChar", 2);
			}
			break;
			
		case JackTokenizer.TT_SYMBOL:
			
			switch(this.tokenizer.peekVal()) {
			case "(":
				this.tokenizer.advance(); // (
				compileExpression();
				this.tokenizer.advance(); // )
				break;
			case "-":
			case "~":
				this.tokenizer.advance(); // - | ~
				String unaryOp = this.tokenizer.symbol();
				compileTerm();
				if(unaryOp.equals("~")) {
					
					this.writer.writeArithmetic("not");
				} else if(unaryOp.equals("-")) {
					this.writer.writeArithmetic("neg");
				}
				
				break;
			}
			
			break;
		}
		
	}
	
	/**
	 * Compiles a (possibly empty) comma- separated list of expressions.
	 * @throws IOException
	 */
	private int compileExpressionList() throws IOException {
		int expresionCounter = 0;
	
		
		while(this.tokenizer.hasMoreTokens()) {
			if(this.tokenizer.peekVal().equals(")")) {
				break;
			}
			//this.tokenizer.advance(); // expression
			
			compileExpression();
			expresionCounter++;
			
			if(this.tokenizer.peekVal().equals(",")) {
				this.tokenizer.advance();
			}
		}
		
		return expresionCounter;
	}
}